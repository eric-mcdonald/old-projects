1. A copy operation creates a new copy of all of the class's resources, while a move operation copies all of its resources to a new object, and deletes them from the previous object. A move operation is useful for optimizing your code (if you are copying a lot of resources), taking less memory, and sometimes if a copy operation isn't allowed but a move is.
2. Dynamically allocating addresses to objects (pointer-to-pointer) instead of the objects themselves means that you must initalize each index of the pointer-to-pointer array to a pointer to an object. This means that a pointer-to-pointer array does not contain the object structures themselves. An array that contains objects means that at each index there is the object structure.
3. I added a move constructor (Text(Text &&src);) to my sict::Text class, and an overloaded move-assignment operator (Text &operator=(Text &&src);) to my code and implemented the move constructor by assigning src#strings and src#strings_sz to the new object, and then setting src to an empty state. I implemented the move-assignment operator by checking if src is not the same object as the left-hand-side object, if it isn't, then it deletes the resources created in 'this' object copies over the resources from src, and sets src to an empty state.